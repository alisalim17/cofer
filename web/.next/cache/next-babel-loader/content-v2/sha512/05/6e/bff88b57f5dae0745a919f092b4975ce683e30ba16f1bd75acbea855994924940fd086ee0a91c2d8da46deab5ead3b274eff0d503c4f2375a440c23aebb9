{"ast":null,"code":"import _regeneratorRuntime from \"D:/Proglamlama/Visual Studio Code Projects/projects/Best Projects/cofer/web/node_modules/next/node_modules/@babel/runtime/regenerator\";\nimport _defineProperty from \"D:/Proglamlama/Visual Studio Code Projects/projects/Best Projects/cofer/web/node_modules/next/node_modules/@babel/runtime/helpers/esm/defineProperty\";\nimport _asyncToGenerator from \"D:/Proglamlama/Visual Studio Code Projects/projects/Best Projects/cofer/web/node_modules/next/node_modules/@babel/runtime/helpers/esm/asyncToGenerator\";\n\nvar _s = $RefreshSig$();\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nimport { useMutation } from 'react-query';\n\nfunction fetcher(endpoint, requestInit, query, variables) {\n  return /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {\n    var res, json, message;\n    return _regeneratorRuntime.wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            _context.next = 2;\n            return fetch(endpoint, _objectSpread(_objectSpread({\n              method: 'POST'\n            }, requestInit), {}, {\n              body: JSON.stringify({\n                query: query,\n                variables: variables\n              })\n            }));\n\n          case 2:\n            res = _context.sent;\n            _context.next = 5;\n            return res.json();\n\n          case 5:\n            json = _context.sent;\n\n            if (!json.errors) {\n              _context.next = 9;\n              break;\n            }\n\n            message = json.errors[0].message;\n            throw new Error(message);\n\n          case 9:\n            return _context.abrupt(\"return\", json.data);\n\n          case 10:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, _callee);\n  }));\n}\n/** All built-in and custom scalars, mapped to their actual values */\n\n\nexport var LoginDocument = \"\\n    mutation Login($input: LoginInput!) {\\n  login(input: $input) {\\n    ok\\n  }\\n}\\n    \";\nexport var useLoginMutation = function useLoginMutation(dataSource, options) {\n  _s();\n\n  return useMutation(function (variables) {\n    return fetcher(dataSource.endpoint, dataSource.fetchParams || {}, LoginDocument, variables)();\n  }, options);\n};\n\n_s(useLoginMutation, \"wwwtpB20p0aLiHIvSy5P98MwIUg=\", false, function () {\n  return [useMutation];\n});","map":{"version":3,"sources":["D:/Proglamlama/Visual Studio Code Projects/projects/Best Projects/cofer/web/src/generated/graphql.ts"],"names":["useMutation","fetcher","endpoint","requestInit","query","variables","fetch","method","body","JSON","stringify","res","json","errors","message","Error","data","LoginDocument","useLoginMutation","dataSource","options","fetchParams"],"mappings":";;;;;;;;;;AAAA,SAASA,WAAT,QAAgD,aAAhD;;AAMA,SAASC,OAAT,CAAoCC,QAApC,EAAsDC,WAAtD,EAAgFC,KAAhF,EAA+FC,SAA/F,EAAuH;AACrH,+EAAO;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,mBACaC,KAAK,CAACJ,QAAD;AACrBK,cAAAA,MAAM,EAAE;AADa,eAElBJ,WAFkB;AAGrBK,cAAAA,IAAI,EAAEC,IAAI,CAACC,SAAL,CAAe;AAAEN,gBAAAA,KAAK,EAALA,KAAF;AAASC,gBAAAA,SAAS,EAATA;AAAT,eAAf;AAHe,eADlB;;AAAA;AACCM,YAAAA,GADD;AAAA;AAAA,mBAOcA,GAAG,CAACC,IAAJ,EAPd;;AAAA;AAOCA,YAAAA,IAPD;;AAAA,iBASDA,IAAI,CAACC,MATJ;AAAA;AAAA;AAAA;;AAUKC,YAAAA,OAVL,GAUiBF,IAAI,CAACC,MAAL,CAAY,CAAZ,CAVjB,CAUKC,OAVL;AAAA,kBAYG,IAAIC,KAAJ,CAAUD,OAAV,CAZH;;AAAA;AAAA,6CAeEF,IAAI,CAACI,IAfP;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,GAAP;AAiBD;AACD;;;AA6EA,OAAO,IAAMC,aAAa,gGAAnB;AAOP,OAAO,IAAMC,gBAAgB,GAAG,SAAnBA,gBAAmB,CAI1BC,UAJ0B,EAK1BC,OAL0B;AAAA;;AAAA,SAO5BpB,WAAW,CACT,UAACK,SAAD;AAAA,WAAwCJ,OAAO,CAAwCkB,UAAU,CAACjB,QAAnD,EAA6DiB,UAAU,CAACE,WAAX,IAA0B,EAAvF,EAA2FJ,aAA3F,EAA0GZ,SAA1G,CAAP,EAAxC;AAAA,GADS,EAETe,OAFS,CAPiB;AAAA,CAAzB;;GAAMF,gB;UAOTlB,W","sourcesContent":["import { useMutation, UseMutationOptions } from 'react-query';\nexport type Maybe<T> = T | null;\nexport type Exact<T extends { [key: string]: unknown }> = { [K in keyof T]: T[K] };\nexport type MakeOptional<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]?: Maybe<T[SubKey]> };\nexport type MakeMaybe<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]: Maybe<T[SubKey]> };\n\nfunction fetcher<TData, TVariables>(endpoint: string, requestInit: RequestInit, query: string, variables?: TVariables) {\n  return async (): Promise<TData> => {\n    const res = await fetch(endpoint, {\n      method: 'POST',\n      ...requestInit,\n      body: JSON.stringify({ query, variables }),\n    });\n\n    const json = await res.json();\n\n    if (json.errors) {\n      const { message } = json.errors[0];\n\n      throw new Error(message);\n    }\n\n    return json.data;\n  }\n}\n/** All built-in and custom scalars, mapped to their actual values */\nexport type Scalars = {\n  ID: string;\n  String: string;\n  Boolean: boolean;\n  Int: number;\n  Float: number;\n};\n\nexport type FieldError = {\n  __typename?: 'FieldError';\n  field: Scalars['String'];\n  message: Scalars['String'];\n};\n\nexport type LoginInput = {\n  usernameOrEmail: Scalars['String'];\n  password: Scalars['String'];\n};\n\nexport type Mutation = {\n  __typename?: 'Mutation';\n  login: RegisterResponse;\n  register: RegisterResponse;\n  logout: Scalars['Boolean'];\n};\n\n\nexport type MutationLoginArgs = {\n  input: LoginInput;\n};\n\n\nexport type MutationRegisterArgs = {\n  input: RegisterInput;\n};\n\nexport type Query = {\n  __typename?: 'Query';\n  allUsers?: Maybe<Array<User>>;\n  me?: Maybe<User>;\n};\n\nexport type RegisterInput = {\n  username: Scalars['String'];\n  email: Scalars['String'];\n  password: Scalars['String'];\n};\n\nexport type RegisterResponse = {\n  __typename?: 'RegisterResponse';\n  ok: Scalars['Boolean'];\n  errors?: Maybe<Array<FieldError>>;\n  user?: Maybe<User>;\n};\n\nexport type User = {\n  __typename?: 'User';\n  id: Scalars['String'];\n  username: Scalars['String'];\n  email: Scalars['String'];\n};\n\nexport type LoginMutationVariables = Exact<{\n  input: LoginInput;\n}>;\n\n\nexport type LoginMutation = (\n  { __typename?: 'Mutation' }\n  & { login: (\n    { __typename?: 'RegisterResponse' }\n    & Pick<RegisterResponse, 'ok'>\n  ) }\n);\n\n\nexport const LoginDocument = `\n    mutation Login($input: LoginInput!) {\n  login(input: $input) {\n    ok\n  }\n}\n    `;\nexport const useLoginMutation = <\n      TError = unknown,\n      TContext = unknown\n    >(\n      dataSource: { endpoint: string, fetchParams?: RequestInit }, \n      options?: UseMutationOptions<LoginMutation, TError, LoginMutationVariables, TContext>\n    ) => \n    useMutation<LoginMutation, TError, LoginMutationVariables, TContext>(\n      (variables?: LoginMutationVariables) => fetcher<LoginMutation, LoginMutationVariables>(dataSource.endpoint, dataSource.fetchParams || {}, LoginDocument, variables)(),\n      options\n    );"]},"metadata":{},"sourceType":"module"}